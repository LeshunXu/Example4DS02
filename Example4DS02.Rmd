---
title: "Water-level Predictions for Fraser River"
author: "by Leshun Xu"
date: "18 Apr 2019"
output:
  html_document: 
published: no
status: processed
tags: R forecast
draft: no
---

This is an example on how the GAM package works for the prediction of the water level of Fraser River in British Columbia, Canada. The data set is downloaded from the Canada government website (https://wateroffice.ec.gc.ca/download/report_e.html?dt=dd&df=ddf&md=1&ext=csv Please read the terms before you use the data).
  
```{r setup, include=FALSE}
library(data.table)
library(mgcv)
library(ggplot2)
suppressMessages(library(lubridate, warn.conflicts = FALSE))
library(dplyr)
library(scales)
```

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
library(knitr)
setwd("D:/2019 Example4DataScience/Example4DS02")
opts_knit$set(root.dir = "D:/2019 Example4DataScience/Example4DS02")
```
```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
### Please refer to the website:
### https://stackoverflow.com/questions/24387376/r-error-could-not-find-function-multiplot-using-cookbook-example
# Multiple plot function
#
# ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)
# - cols:   Number of columns in layout
# - layout: A matrix specifying the layout. If present, 'cols' is ignored.
#
# If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),
# then plot 1 will go in the upper left, 2 will go in the upper right, and
# 3 will go all the way across the bottom.
#
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {
  require(grid)

  # Make a list from the ... arguments and plotlist
  plots <- c(list(...), plotlist)

  numPlots = length(plots)

  # If layout is NULL, then use 'cols' to determine layout
  if (is.null(layout)) {
    # Make the panel
    # ncol: Number of columns of plots
    # nrow: Number of rows needed, calculated from # of cols
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),
                    ncol = cols, nrow = ceiling(numPlots/cols))
  }

 if (numPlots==1) {
    print(plots[[1]])

  } else {
    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
      # Get the i,j matrix positions of the regions that contain this subplot
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))

      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,
                                      layout.pos.col = matchidx$col))
    }
  }
}

#####################
```

## Overview of the data

The attached .csv file contains the daily discharge and the daily water level of a part of Fraser River, from 04-Jul-1978 to 29-Jan-2019. The data from 01-Jan-2011 to 31-Dec-2018 is extracted out as the data set used in this example. The following graphs show the distributions and the pattern of the values within the eight-year period.

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
water <- read.csv("waterflow.csv", header = TRUE, sep = ",", skip = 1)

water$Date <- as.Date(water$Date)
water <- water[which(water$Date>=as.Date("2011-01-01") & water$Date<=as.Date("2018-12-31")),]
water <- as.data.table(water)
discharge <- water[which(water$PARAM==1),]
flows <- water[which(water$PARAM==2),]

par(mfrow=c(1,2))

# Distibution of discharge     
hist(discharge$Value, probability = TRUE, breaks = 50, col="grey",
     xlab = "Observed Values", ylab = "Density (Propotion)", main = "Distribution of the Discharge")

# Distibution of flows     
hist(flows$Value, probability = TRUE, breaks = 50, col="grey",
     xlab = "Observed Values", ylab = "Density (Propotion)", main = "Distribution of the Water Level")

par(mfrow=c(1,1))
```

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
ggp1 <- ggplot(discharge, aes(Date, Value)) + geom_line() +
  theme(axis.title = element_text(size = 12, face = "bold")) +
  labs(x = "Date", y = "Discharge")
ggp2 <- ggplot(flows, aes(Date, Value)) + geom_line() +
  theme(axis.title = element_text(size = 12, face = "bold")) +
  labs(x = "Date", y = "Water Level")
multiplot(ggp1, ggp2, cols=2)

```

### GAM model for the water level

In this example, we only focus on the prediction of water levels.
Since we have the history data, in the following model,
we use $lag_i$ ($i$ = 1, 2, 3, 4, 60, 362) to stand for the water level
$i$ day(s) before the predicted date. The $month$s are
translated into numbers between 1 and 12. We introduce the following GAM model:
$$Value = \beta_0 + f_0(month, 6) + f_1(lag_1, 8) + f_2(lag_2, 8) + f_3(lag_3, 8) + f_4(lag_4, 8) + f_{60}(lag_{60}, 8) + f_{362}(lag_{362}, 8) + \epsilon,$$
where $f_{\cdot}(\cdot, k)$'s are functions expanded by cubic splines with $k$ knots.
The following graph implies that the model provides a good prediction for a training dataset (i.e. the eight-year period).


```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
n <- nrow(flows)
f.data.lags.368 <- mutate(flows, month = month(Date),
                      lag1 = c(rep(0,1), flows$Value[1:(n-1)]),
                      lag2 = c(rep(0,2), flows$Value[1:(n-2)]),
                      lag3 = c(rep(0,3), flows$Value[1:(n-3)]),
                      lag4 = c(rep(0,4), flows$Value[1:(n-4)]),
                      lag60 = c(rep(0,60), flows$Value[1:(n-60)]),
                      lag362 = c(rep(0,362), flows$Value[1:(n-362)])
                      )
f.data.lags.year368 <- f.data.lags.368[363:n,]
f.data.lags.year368 <- as.data.table(f.data.lags.year368)

gam_lag368 <- gam(Value ~
              s(month, bs = "cr", k = 6) +
              # as.factor(month) +
              s(lag1, bs = "cr", k = 8) +
              s(lag2, bs = "cr", k = 8) +
              s(lag3, bs = "cr", k = 8) +
              s(lag4, bs = "cr", k = 8) +
              s(lag60, bs = "cr", k = 8) +
              s(lag362, bs = "cr", k = 8),
             data = f.data.lags.year368,
             family = gaussian)

datas <- rbindlist(list(f.data.lags.year368[, .(Value, Date)],
                        data.table(value = gam_lag368$fitted.values, Date = f.data.lags.year368[, Date])))
datas[, type := c(rep("Real", nrow(f.data.lags.year368)), rep("Fitted", nrow(f.data.lags.year368)))]

ggplot(data = datas, aes(Date, Value, group = type, colour = type)) +
  geom_line(size = 0.8) +
  theme_bw() +
  labs(x = "Time", y = "Value")
# summary(gam_lag368)
```

### Prediction for tomorrow

Supposedly, we already know the water level of today and the previous days, and we are going to predict the water level for tomorrow. It means the model has to be trained each day, and then it makes a prediction for the next day. In the following graph, 84 'tomorrows' are predicted. The solid line represents the predicted value; the black dots, true values; and the grey belt, the prediction intervals.

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
obsN <- nrow(f.data.lags.year368)

prdmat.all <- data.frame(matrix(ncol = 9, nrow = 0))
colnames(prdmat.all) <- c("Date", "Value", "low", "pred", "up", "error", "sd.error", "df.res", "multip")
pred.days <- 1  # number of the days need to be predicted
n.win <- 84     # the number of windows
win.list <- list()
for (i in n.win:1) {
  tr.data <- f.data.lags.year368[1:(obsN-pred.days*i),]
  te.data <- f.data.lags.year368[(obsN-pred.days*i+1):(obsN-pred.days*(i-1)),]
  obs <- nrow(tr.data)
  gam_lag368 <- gam(Value ~ 
              # s(month, bs = "cr", k = 6) +
              as.factor(month) +
              s(lag1, bs = "cr", k = 8) +
              s(lag2, bs = "cr", k = 8) +
              s(lag3, bs = "cr", k = 8) +
              s(lag4, bs = "cr", k = 8) +
              s(lag60, bs = "cr", k = 8) +
              s(lag362, bs = "cr", k = 8),
             data = tr.data,
             family = gaussian)
  tdf <- gam_lag368$df.residual

  tempd <- as.matrix(tr.data[, 6:12])
  xbar <- as.vector(colMeans(tempd))
  dnmat <- apply(tempd, 2, scale, scale=FALSE, center=TRUE)
  dnmtr <- sum(sum(dnmat^2))
  
  prdmat <- data.frame(matrix(ncol = 9, nrow = 0))
  colnames(prdmat) <- c("Date", "Value", "low", "pred", "up", "error", "sd.error", "df.res", "multip")
  
  for (j in 1:pred.days) {
    p <- predict(gam_lag368, newdata = te.data[j,],  se.fit = TRUE)
    
    te.data <- as.data.frame(te.data)
    
    mse <- mean((te.data$Value[j] - p$fit)^2)
    term1 <- 1 + 1/obs + sum((te.data[j,6:12]-xbar)^2)/dnmtr
    sder <- sqrt(mse*term1)
    qte <- qt(.975, tdf)
    pr.intl <- p$fit - qte * sder
    pr.intu <- p$fit + qte * sder
    prdmat[j,2:9] <- c(te.data$Value[j], pr.intl, p$fit, pr.intu, mse, sder, tdf, qte)
    prdmat[j,1] <- as.character(te.data$Date[j])
    
    
    tempd2 <- as.matrix(select(te.data, 6:12))[j,]
    
    if (j+1 <= pred.days){
      te.data[(j+1), 7:10] <- c(p$fit, te.data[j, 7:9])
    }
    te.data <- as.data.table(te.data)
  }
  win.name <- paste("win",i,sep = "")
  win.list[[win.name]] <- prdmat
  prdmat.all <- rbind(prdmat.all, prdmat)
}

prdmat.all$Date <- as.Date(prdmat.all$Date)
prdmat.all <- as.data.table(prdmat.all)
d1 <- prdmat.all[,1:2]
d2 <- prdmat.all[,c(1,3:5)]
colnames(d2) <- c("Date",  "low", "Value", "up")
ggplot(d1, aes(Date, Value))+
    geom_point()+
    geom_line(data=d2)+
    geom_ribbon(data=d2, aes(ymin=low, ymax=up),alpha=0.3) +
    scale_x_date(labels = date_format("%d-%m-%y"))+
    labs(x = "Date (dd-mm-yy)", y = "Water Level")

```

### Prediction for the next 7 days

We use the water levels of today and the previous days to predict the following seven days without using any updated information. The prediction intervals cover all true values. The following graphs contains 12 seven-day predictions.

```{r, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}

prdmat.all <- data.frame(matrix(ncol = 9, nrow = 0))
colnames(prdmat.all) <- c("Date", "Value", "low", "pred", "up", "error", "sd.error", "df.res", "multip")
pred.days <- 7  # number of the days need to be predicted
n.win <- 12     # the number of windows
win.list <- list()
for (i in n.win:1) {
  tr.data <- f.data.lags.year368[1:(obsN-pred.days*i),]
  te.data <- f.data.lags.year368[(obsN-pred.days*i+1):(obsN-pred.days*(i-1)),]
  obs <- nrow(tr.data)
  gam_lag368 <- gam(Value ~ 
              s(month, bs = "cr", k = 6) +
              # as.factor(month) +
              s(lag1, bs = "cr", k = 8) +
              s(lag2, bs = "cr", k = 8) +
              s(lag3, bs = "cr", k = 8) +
              s(lag4, bs = "cr", k = 8) +
              s(lag60, bs = "cr", k = 8) +
              s(lag362, bs = "cr", k = 8),
             data = tr.data,
             family = gaussian)
  tdf <- gam_lag368$df.residual

  tempd <- as.matrix(tr.data[, 6:12])
  xbar <- as.vector(colMeans(tempd))
  dnmat <- apply(tempd, 2, scale, scale=FALSE, center=TRUE)
  dnmtr <- sum(sum(dnmat^2))
  
  prdmat <- data.frame(matrix(ncol = 9, nrow = 0))
  colnames(prdmat) <- c("Date", "Value", "low", "pred", "up", "error", "sd.error", "df.res", "multip")

  for (j in 1:pred.days) {
    p <- predict(gam_lag368, newdata = te.data[j,],  se.fit = TRUE)
    
    te.data <- as.data.frame(te.data)
    
    mse <- mean((te.data$Value[j] - p$fit)^2)
    term1 <- 1 + 1/obs + sum((te.data[j, 6:12]-xbar)^2)/dnmtr
    sder <- sqrt(mse*term1)
    qte <- qt(.975, tdf)
    pr.intl <- p$fit - qte * sder
    pr.intu <- p$fit + qte * sder
    prdmat[j,2:9] <- c(te.data$Value[j], pr.intl, p$fit, pr.intu, mse, sder, tdf, qte)
    prdmat[j,1] <- as.character(te.data$Date[j])
    
    tempd2 <- as.matrix(select(te.data, 6:12))[j,]
    
    if (j+1 <= pred.days){
      te.data[(j+1), 7:10] <- c(p$fit, te.data[j, 7:9])
    }
    te.data <- as.data.table(te.data)
  }
  win.name <- paste("win",i,sep = "")
  win.list[[win.name]] <- prdmat
  prdmat.all <- rbind(prdmat.all, prdmat)
}

prdmat.all$Date <- as.Date(prdmat.all$Date)
prdmat.all <- as.data.table(prdmat.all)
d1 <- prdmat.all[,1:2]
d2 <- prdmat.all[,c(1,3:5)]
colnames(d2) <- c("Date",  "low", "Value", "up")
ggplot(d1, aes(Date, Value))+
    geom_point()+
    geom_line(data=d2)+
    geom_ribbon(data=d2, aes(ymin=low, ymax=up),alpha=0.3) +
    scale_x_date(labels = date_format("%d-%m-%y"))+
    labs(x = "Date (dd-mm-yy)", y = "Warer Level")

```

**Remark to model:**

If we set "month" as a factor with 12 levels, we will get similar results, but with a little bit more freedom for the residuals. In this example, we will not go further into the discussion on overfitting, how to choose knots and lags, and whether treating "month" as a factor is good, etc.

